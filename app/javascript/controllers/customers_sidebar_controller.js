import { Controller } from "@hotwired/stimulus"

export default class extends Controller {
  static targets = ["badge", "item", "search"]

  connect() {
    this.openCustomerId = window.OPEN_CUSTOMER_ID || null
    this.unreadCounts = new Map()
    this.messageUpdateTimers = {}

    // Observe only DOM insertions inside sidebar
    this.observer = new MutationObserver(mutations => {
      mutations.forEach(m => this.processMutation(m))
    })

    this.observer.observe(this.element, { childList: true, subtree: true })
  }

  disconnect() {
    this.observer.disconnect()
  }

  filter(event) {
    const query = event.target.value.toLowerCase().trim()

    this.itemTargets.forEach(item => {
      const name = item.dataset.customerName?.toLowerCase() || ""
      const number = item.dataset.customerNumber || ""

      const matches =
        name.includes(query) ||
        number.includes(query)

      item.classList.toggle("hidden", !matches)
    })
  }

  /** When a chat row is clicked */
  openCustomer(event) {
    const el = event.currentTarget
    const customerId = Number(el.dataset.customerId)
    if (!customerId) return

    this.openCustomerId = customerId
    window.OPEN_CUSTOMER_ID = customerId

    this.setUnread(customerId, 0)
  }

  /** Process mutation and detect last_message updates */
  processMutation(mutation) {
    // ignore mutations generated by updating unread badge itself
    if (mutation.target.closest(".unread-badge")) return

    // check added nodes only
    mutation.addedNodes?.forEach(node => {
      if (!(node instanceof Element)) return

      // direct match
      if (this.isLastMessageNode(node)) this.handleLastMessage(node)

      // child matches
      node.querySelectorAll?.("[id^='last_message_customer_']")
        .forEach(n => this.handleLastMessage(n))
    })
  }

  /** Check if element is the last_message node */
  isLastMessageNode(node) {
    return node.id?.startsWith("last_message_customer_")
  }

  /** Collapse multiple updates into one unread increment */
  handleLastMessage(node) {
    const match = node.id.match(/^last_message_customer_(\d+)$/)
    if (!match) return
    const customerId = Number(match[1])
    // skip if debounce active
    if (this.messageUpdateTimers[customerId]) return

    this.messageUpdateTimers[customerId] = setTimeout(() => {
      delete this.messageUpdateTimers[customerId]

      if (this.openCustomerId === customerId) {
        this.setUnread(customerId, 0)
      } else {
        const prev = this.unreadCounts.get(customerId) || 0
        this.setUnread(customerId, prev + 1)
      }

    }, 80)
  }

  /** Update unread badge */
  setUnread(customerId, value) {
    const badge = this.element.querySelector(`.unread-badge[data-customer-id="${customerId}"]`)

    if (!badge) return
    if (value > 0) {
      this.unreadCounts.set(customerId, value)
      badge.textContent = value
      badge.classList.remove("hidden")
    } else {
      this.unreadCounts.delete(customerId)
      badge.textContent = "0"
      badge.classList.add("hidden")
    }
  }
}
